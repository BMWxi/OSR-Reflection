
function TReflectionMap.TileOnMM(Tile: TPoint): Boolean;
var
  Point: TPoint;
begin
  Point := Reflect.Tiles.TileToMM(Tile);
  Result := PointInBox(Point, intToBox(MMX1, MMY1, MMX2, MMY2));
end;

function TReflectionMap.WalkToTileMM(Tile: TPoint): boolean;
var
  Point: TPoint;
begin
  Result := False;
  if not TReflectionMap.TileOnMM(Tile) then
    Exit;
  Point := TReflectionTiles.TileToMM(Tile);
  HumanMMouse(Point, 0, 0);
  Wait(RandomRange(150, 220));
  FastClick(MOUSE_LEFT);
  Result := True;
end;

function TReflectionMap.WalkToTileMS(Tile: TPoint): boolean;
var
  Point: TPoint;
  X, Y: Integer;
  Time: Timer
begin
  if not isLoggedIn then
    Exit;
  Point := TReflectionTiles.TileToMS(Tile);
  if (Point.X = -1) and (Point.Y = -1) then
    exit;
  HumanMMouse(Point, 0, 0);
  GetMousePos(X, Y);
  if TReflectionText.WaitUpText('Walk here', 50) then
    FastClick(MOUSE_LEFT)
  else
  begin
    FastClick(MOUSE_RIGHT);
    Wait(RandomRange(400, 500));
    if not TReflectionText.ChooseOption('Walk here') then
      TReflectionText.ChooseOption('Cancel')
  end;
  Wait(RandomRange(120, 180));
  Timer.Start;
  FFlag(5);
  Result := Timer.TimeElapsed < 30000;
end;

function TReflectionMap.WindPath(Xs, Ys, Xe, Ye, Gravity, Wind, MinWait,
  MaxWait, MaxStep, TargetArea: Extended): TPointArray;
var
  VeloX, VeloY, WindX, WindY, VeloMag, Dist, RandomDist, LastDist: Extended;
  Step, Sqrt2, Sqrt3, Sqrt5: Extended;
  LastX, LastY: Integer;
begin
  Sqrt2:= Sqrt(2);
  Sqrt3:= Sqrt(3);
  Sqrt5:= Sqrt(5);
  while Hypot(Xs - Xe, Ys - Ye) > 1 do
  begin
    Dist:= hypot(Xs - Xe, Ys - Ye);
    Wind:= MinE(Wind, Dist);
    if Dist >= TargetArea then
    begin
      WindX:= WindX / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
      WindY:= WindY / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
    end else
    begin
      WindX:= WindX / Sqrt2;
      WindY:= WindY / Sqrt2;
      if (MaxStep < 3) then
        MaxStep:= random(3) + 3.0
      else
        MaxStep:= MaxStep / Sqrt5;
    end;
    VeloX:= VeloX + WindX;
    VeloY:= VeloY + WindY;
    VeloX:= VeloX + Gravity * (Xe - Xs) / Dist;
    VeloY:= VeloY + Gravity * (Ye - Ys) / Dist;
    if Hypot(VeloX, VeloY) > MaxStep then
    begin
      RandomDist:= MaxStep / 2.0 + random(0, (round(MaxStep) div 2));
      VeloMag:= sqrt(VeloX * VeloX + VeloY * VeloY);
      VeloX:= (VeloX / VeloMag) * RandomDist;
      VeloY:= (VeloY / VeloMag) * RandomDist;
    end;
    LastX:= Round(Xs);
    LastY:= Round(Ys);
    Xs:= Xs + VeloX;
    Ys:= Ys + VeloY;
    SetArrayLength(Result, GetArrayLength(Result) + 1);
    Result[ High(Result) ] := Point(Round(Xs), Round(Ys));
    Step:= hypot(Xs - LastX, Ys - LastY);
    LastDist:= Dist;
  end;
end;

function TReflectionMap.BlindWalkMS(Tile: TPoint; Dist: Integer = 2): Boolean;
var
  I, Tries: Integer;
  OurTile, DestTile: TPoint;
  CTRLPoints: TPointArray;
begin
  repeat
    OurTile := TReflectionTiles.GetGlobalTile;
    CtrlPoints := TReflectionMap.WindPath(OurTile.x, OurTile.y, Tile.x, Tile.y, 5.0, 2.5, 0.0, 0.0, 1.5, 1.0);
    Inc(Tries);
    if(Tries > 20)then
      Exit;
    for I:= High(CtrlPoints) downto 0 do
      if TReflectionMap.WalkToTileMS(CtrlPoints[I]) then
      begin
        Result := TReflectionTiles.DistanceFromTile(Tile) <= Dist;
        Break;
      end;
  until(Result);
end;

function TReflectionMap.WalkPathMM(Path: TPointArray; Reverse: Boolean = False): boolean;
var
  I, H, T, Fails, lP: integer;
  P, MM, MMF: TPoint;
  Temp: TPointArray;
  K: Timer;
begin
  Temp := CopyTPA(Path);
  ColorToleranceSpeed(1);
  T := GetSystemTime + 10000 + Random(2000);
  Fails := 0;
  lP := 0;
  if Reverse then
    InvertTpa(Temp);
  H := High(Temp);
  while (not Result) and (GetSystemTime < T) and (Fails < 5) do
  begin
    if (not isLoggedIn()) then
      Exit;
    P := TReflectionTiles.GetGlobalTile;
    for I := H downto 0 do
    begin
      if ((I - lP) > 3) then
        Continue
      else
        lP := I;
      MM := TReflectionTiles.TileToMM(Temp[I]);
      if (MM.X = MMF.X) and (MM.Y = MMF.Y) then
        Inc(Fails);
      if TReflectionMap.TileOnMM(Temp[i]) then
      begin
        TReflectionMap.WalkToTileMM(Temp[i]);
        K.Start;
        repeat
        {if not Reflect.Player.IsMoving then
          break;}
        until((K.timeElapsed > 2000) or FFlag(30));
        MMF := MM;
        if (I = H) then
          FFlag(5)
        else
          FFlag(25);
        T := getSystemTime + 7000 + Random(1000);
        Break;
      end;
    end;
    Result := (I = H);
  end;
  FFlag(5);
end;

function TReflectionMap.BlindWalk(Tile: TPoint; Dist: Integer = 5): Boolean;
var
  I, Tries: Integer;
  OurTile, DestTile: TPoint;
  CTRLPoints: TPointArray;
begin
  repeat
    OurTile := TReflectionTiles.GetGlobalTile;
    CtrlPoints := TReflectionMap.WindPath(OurTile.x, OurTile.y, Tile.x, Tile.y, 5.0, 2.5, 0.0, 0.0, 1.5, 1.0);
    Inc(Tries);
    if(Tries > 20)then
      Exit;
    for I:= High(CtrlPoints) downto 0 do
      if TReflectionMap.WalkToTileMM(CtrlPoints[I]) then
      begin
        Result := TReflectionTiles.DistanceFromTile(Tile) <= Dist;
        Break;
      end;
  until(Result);
end;
