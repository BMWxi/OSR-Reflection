type
  TReflectGroundItem = record
    Id, Quantity: Integer;
    Tile: TPoint;
  end;

  TReflectGroundItemArray = array of TReflectGroundItem;

function GroundItem(Id, Quantity: Integer; Tile: TPoint): TReflectGroundItem;
begin
  Result.Id := Id;
  Result.Quantity := Quantity;
  Result.Tile := Tile;
end;

function TReflectionInternals.GetGroundItemsAt(Tile: TPoint; BaseX, BaseY,
  Plane: Integer): TReflectGroundItemArray;
var
  Id, Quantity, Iteration: Integer;
begin
  Reflect.Mem.Get3DObject(ckNull, ckGroundArray, Client_GroundItems, 0, 0,
    Tile.X, Tile.Y, Plane);
  Reflect.Mem.GetObject(ckGroundArray, ckGroundList, LinkedList_Head, 0, 0);
  Reflect.Mem.GetObject(ckGroundList, ckGroundList, Node_next, 1, 0);
  SetLength(Result, 128);
  while (HookCache[TCacheKey.ckGroundList][Iteration] <> -1) and
    (HookCache[TCacheKey.ckGroundList][Iteration] <> 0) and
    (HookCache[TCacheKey.ckGroundList][iteration] <>
    HookCache[TCacheKey.ckGroundList][iteration + 1]) do
  begin
    Id := Reflect.Smart.GetInt(HookCache[TCacheKey.ckGroundList][Iteration + 1],
       Item_Id);
    Quantity := Reflect.Smart.GetInt(
      HookCache[TCacheKey.ckGroundList][Iteration + 1], Item_stackSize);
    if (Id < 0) or (Quantity < 0) then
      Break;
    Result[Iteration] := GroundItem(Id, Quantity, Point(Tile.X + BaseX, Tile.Y + BaseY));
    Reflect.Mem.GetObject(ckGroundList, ckGroundList, Node_Next, Iteration + 2, Iteration + 1);
    Inc(Iteration);
  end;
  SetLength(Result, Iteration);
end;

procedure TReflectGroundItemArray.GetAt(RealTile: TPoint);
var
  BaseX, BaseY, Plane: Integer;
begin
  BaseX := Reflect.Internals.BaseX;
  BaseY := Reflect.Internals.BaseY;
  Plane := Reflect.Tiles.GetPlane;
  Self := Reflect.Internals.GetGroundItemsAt(Point(RealTile.X - BaseX,
    RealTile.Y - BaseY), BaseX, BaseY, Plane);
  Reflect.Mem.FreeObjects(ckGroundArray, False);
  Reflect.Mem.FreeObjects(ckGroundList, False);
end;

procedure TReflectGroundItemArray.Get(Distance: Integer = 103);
var
   X, Y, BaseX, BaseY, Plane, L, I, H, HighX, HighY: Integer;
   TempArray, TempArray2: TReflectGroundItemArray;
   Position: TPoint;
begin
  Position := Reflect.Tiles.GetGlobalTile;
  Distance := Round(Distance / 2);
  BaseX := Reflect.Internals.BaseX;
  BaseY := Reflect.Internals.BaseY;
  Position := Point(Position.X - BaseX, Position.Y - BaseY);
  Plane := Reflect.Tiles.GetPlane;
  HighX := Position.X + Distance;
  HighY := Position.Y + Distance;
  if HighX > 103 then
    HighX := 103;
  if HighY > 103 then
    HighY := 103;
  SetLength(Self, 10817);
  for X := Position.X - Distance to HighX do
    for Y := Position.Y - Distance to HighY do
    begin
      SetLength(TempArray, 0);
      TempArray := Reflect.Internals.GetGroundItemsat(Point(X, Y), BaseX,
        BaseY, Plane);
      Reflect.Mem.FreeObjects(ckGroundArray, False);
      Reflect.Mem.FreeObjects(ckGroundList, False);
      L := Length(TempArray);
      if (L > 0) then
      begin
        SetLength(TempArray2, Length(TempArray2) + L);
        H := Length(TempArray2);
        for I := 0 to High(TempArray) do
          TempArray2[H - L + I] := TempArray[I];
      end;
    end;
  Self := TempArray2;
end;
